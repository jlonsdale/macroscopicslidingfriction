<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Rough Surface – Three.js (spectral synthesis)</title>
  <style>
    html, body { height: 100%; margin: 0; background: #0b0d10; color: #e6e6e6; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial; }
    #app { position: fixed; inset: 0; }
    .credits { position: fixed; bottom: .5rem; right: .75rem; opacity: .6; font-size: 12px; }
    .credits a { color: #fff; text-decoration: none; border-bottom: 1px dotted #999; }
    .hud { position: fixed; left: .75rem; bottom: .75rem; background: rgba(20,22,26,.6); padding: .5rem .6rem; border-radius: .6rem; font-size: 12px; line-height: 1.4; }
    .tests { position: fixed; top: .75rem; left: .75rem; background: rgba(20,22,26,.7); padding: .6rem .75rem; border-radius: .6rem; font-size: 12px; line-height: 1.35; max-width: 50ch; box-shadow: 0 2px 10px rgba(0,0,0,.2); }
    .tests b { color: #fff; }
    .ok { color: #8de18d; }
    .fail { color: #ff8d8d; }
    canvas { display: block; }
  </style>
  
  <!-- Import map fixes the "bare specifier" error by mapping 'three' to a CDN URL -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160/examples/jsm/",
      "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm"
    }
  }
  </script>
</head>
<body>
  <div id="app"></div>
  <div class="hud">Drag to orbit • Scroll to zoom</div>
  <div class="credits">Three.js • Spectral roughness demo</div>
  <div class="tests" id="tests"><b>Self‑tests</b><br/>Booting…</div>

  <!-- Three.js + helpers via ESM (using the import map above) -->
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import GUI from 'lil-gui';

    // --- seeded RNG (Mulberry32) ---
    function mulberry32(a){ return function(){ let t = a += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; } }

    // Map value v in [inMin,inMax] to [outMin,outMax]
    const map = (v,inMin,inMax,outMin,outMax)=> outMin + (outMax-outMin) * ((v-inMin)/(inMax-inMin));

    // --------------
    // Self‑test utils
    // --------------
    const testsEl = document.getElementById('tests');
    function report(lines){ if(testsEl) testsEl.innerHTML = '<b>Self‑tests</b><br/>' + lines.join('<br/>'); }
    function ok(name){ return `<span class="ok">✔</span> ${name}`; }
    function fail(name, msg=''){ return `<span class="fail">✖</span> ${name}${msg?': '+msg:''}`; }
    function stddev(arr){ let n=arr.length; if(!n) return 0; let m=0, m2=0; for(let i=0;i<n;i++){ const x=arr[i]; m+=x; m2+=x*x; } m/=n; return Math.sqrt(Math.max(0, m2/n - m*m)); }
    function nearlyEqual(a,b,eps=1e-3){ return Math.abs(a-b) <= eps; }

    // Scene setup
    const app = document.getElementById('app');
    const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance' });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    app.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0d10);

    const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 1000);
    camera.position.set(10, 7.5, 10);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // Lights
    const hemi = new THREE.HemisphereLight(0xffffff, 0x333333, 0.9);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 1.0);
    dir.position.set(5,8,4);
    scene.add(dir);

    // Plane (periodic domain size L)
    const params = {
      L: 10,            // domain size (periodicity)
      resolution: 192,  // segments per side
      numModes: 250,    // number of Fourier modes (excluding k=0)
      alpha: 2.0,       // PSD ~ q^{-alpha}
      q0: 1.0,          // reference wavenumber (sets roll-off)
      amplitude: 0.6,   // global scale of heights
      wireframe: false,
      autoRotate: true,
      seed: 4,
      colorize: true,
      resetView: () => { camera.position.set(10,7.5,10); controls.target.set(0,0,0); controls.update(); }
    };

    const geo = new THREE.PlaneGeometry(params.L, params.L, params.resolution, params.resolution);
    geo.rotateX(-Math.PI/2);

    const mat = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.0, roughness: 0.95, side: THREE.DoubleSide, wireframe: params.wireframe, vertexColors: true });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.castShadow = false; mesh.receiveShadow = true;
    scene.add(mesh);

    // Ground grid for context
    const grid = new THREE.GridHelper(50, 50, 0x555555, 0x2a2a2a);
    grid.position.y = -params.L*0.5 - 0.001;
    scene.add(grid);

    // Build a set of discrete Fourier modes on the periodic domain
    function buildModes(seed){
      const rand = mulberry32(seed >>> 0);
      const modes = [];
      const Nmax = Math.max(2, Math.round(Math.sqrt(params.numModes))); // search range of integer modes
      // collect candidates with integer (n,m) and sample without replacement until numModes
      const pool = [];
      for(let n=-Nmax; n<=Nmax; n++){
        for(let m=-Nmax; m<=Nmax; m++){
          if(n===0 && m===0) continue;
          pool.push([n,m]);
        }
      }
      // Shuffle pool (Fisher-Yates)
      for(let i=pool.length-1; i>0; i--){ const j = Math.floor(rand()*(i+1)); [pool[i],pool[j]] = [pool[j],pool[i]]; }
      const take = Math.min(params.numModes, pool.length);
      for(let i=0; i<take; i++){
        const [n,m] = pool[i];
        const qmag = (2*Math.PI/params.L) * Math.hypot(n,m);
        const Cq = Math.pow(Math.max(qmag, 1e-6)/Math.max(params.q0,1e-6), -params.alpha); // PSD ~ q^{-alpha}
        const A = params.amplitude * Math.sqrt(Cq) / Math.sqrt(take); // scale to keep variance reasonable
        const phi = 2*Math.PI*rand();
        modes.push({ n, m, A, phi });
      }
      return modes;
    }

    let modes = buildModes(params.seed);

    function applyHeights(){
      const pos = geo.attributes.position;
      const color = new THREE.Color();
      // We'll also compute min/max height for color mapping
      let minH = Infinity, maxH = -Infinity;

      // First pass: compute heights
      const L = params.L;
      const half = L*0.5;
      const heights = new Float32Array(pos.count);
      for(let i=0; i<pos.count; i++){
        const x = pos.getX(i);
        const z = pos.getZ(i);
        // map x,z from [-L/2, L/2] to periodic coords in [0,L]
        const u = (x + half)/L;
        const v = (z + half)/L;
        let h = 0.0;
        for(const {n,m,A,phi} of modes){
          // 2π (n u + m v)
          h += A * Math.cos(2*Math.PI*(n*u + m*v) + phi);
        }
        heights[i] = h;
        if(h<minH) minH = h; if(h>maxH) maxH = h;
      }

      // Second pass: assign to geometry and colorize
      const colors = new Float32Array(pos.count*3);
      for(let i=0; i<pos.count; i++){
        const h = heights[i];
        pos.setY(i, h);
        if(params.colorize){
          // simple height-to-color ramp: deep blue -> white
          const t = (h - minH) / (maxH - minH + 1e-9);
          // use HSL from blue (0.6) to red (0.0) with some desaturation
          const colorObj = new THREE.Color();
          colorObj.setHSL(0.66*(1.0 - t), 0.55, map(t,0,1,0.35,0.85));
          colors[3*i] = colorObj.r; colors[3*i+1] = colorObj.g; colors[3*i+2] = colorObj.b;
        } else {
          colors[3*i] = colors[3*i+1] = colors[3*i+2] = 1.0;
        }
      }
      geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      pos.needsUpdate = true;
      geo.computeVertexNormals();
      geo.normalsNeedUpdate = true;

      // run tests after mutation
      runTests({ heights, minH, maxH });
    }

    applyHeights();

    // GUI
    const gui = new GUI({ title: 'Roughness (Fourier modes)' });
    gui.add(params, 'numModes', 10, 2000, 10).name('Modes').onChange(()=>{ modes = buildModes(params.seed); applyHeights(); });
    gui.add(params, 'alpha', 0.0, 4.0, 0.1).name('PSD exponent α').onChange(()=>{ modes = buildModes(params.seed); applyHeights(); });
    gui.add(params, 'q0', 0.1, 4.0, 0.1).name('q₀ (ref q)').onChange(()=>{ modes = buildModes(params.seed); applyHeights(); });
    gui.add(params, 'amplitude', 0.0, 2.0, 0.01).name('Amplitude').onChange(applyHeights);
    gui.add(params, 'wireframe').onChange(v=>{ mat.wireframe = v; });
    gui.add(params, 'colorize').onChange(applyHeights);
    gui.add(params, 'seed', 1, 9999, 1).name('Seed').onChange(()=>{ modes = buildModes(params.seed); applyHeights(); });
    gui.add(params, 'resetView').name('Reset view');

    // Animation loop
    let t = 0;
    function animate(){
      requestAnimationFrame(animate);
      if(params.autoRotate){ t += 0.002; mesh.rotation.y = t; }
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // Resize handling
    addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // Expose scene to window for quick tinkering
    window.THREE = THREE; window.scene = scene; window.mesh = mesh; window.params = params;

    // -----------------
    // Minimal self-tests
    // -----------------
    function runTests(ctx){
      const lines = [];
      try{
        // T1: Three loaded
        lines.push((THREE && typeof THREE.REVISION !== 'undefined') ? ok(`three@${THREE.REVISION} loaded`) : fail('Three not loaded'));

        // T2: OrbitControls present
        lines.push(typeof OrbitControls === 'function' ? ok('OrbitControls available') : fail('OrbitControls missing'));

        // T3: Vertex count vs resolution
        const expected = (params.resolution + 1) * (params.resolution + 1);
        const actual = geo.attributes.position.count;
        lines.push(expected === actual ? ok('Geometry vertex count') : fail('Geometry vertex count', `${actual} != ${expected}`));

        // T4: Color attribute length
        const colorAttr = geo.getAttribute('color');
        lines.push(colorAttr && colorAttr.count === actual ? ok('Vertex colors attached') : fail('Vertex colors missing/size'));

        // T5: Non-zero variance in heights when amplitude>0 and modes>0
        if(params.amplitude > 0 && params.numModes > 0){
          const sd = stddev(ctx.heights);
          lines.push(sd > 1e-5 ? ok(`Surface variance ok (σ≈${sd.toFixed(3)})`) : fail('Surface variance ~0'));
        } else {
          lines.push(ok('Variance test skipped (amplitude or modes = 0)'));
        }

        // T6: Periodicity check along X and Z edges (sample a few indices)
        const pos = geo.attributes.position;
        const n = params.resolution + 1;
        const samples = 6;
        let periodicOk = true;
        for(let s=0; s<samples; s++){
          const row = Math.floor((s/(samples-1)) * (n-1));
          const left = row*n + 0;           // x = -L/2
          const right = row*n + (n-1);      // x = +L/2
          const top = 0*n + row;            // z = -L/2
          const bottom = (n-1)*n + row;     // z = +L/2
          if(!nearlyEqual(pos.getY(left), pos.getY(right)) || !nearlyEqual(pos.getY(top), pos.getY(bottom))){ periodicOk = false; break; }
        }
        lines.push(periodicOk ? ok('Periodicity across edges') : fail('Edges not periodic (tolerance 1e-3)'));

        // T7: Normals attribute present and sized
        const normalAttr = geo.getAttribute('normal');
        lines.push(normalAttr && normalAttr.count === actual ? ok('Vertex normals computed') : fail('Normals missing/size'));
      }catch(e){
        lines.push(fail('Tests errored', e.message || e));
      }
      report(lines);
    }
  </script>
</body>
</html>
